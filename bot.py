import requests import time import datetime import telebot import json import logging import os from typing import List, Dict, Any, Tuple, Optional from dotenv import load_dotenv # Load environment variables load_dotenv() # Configure logging logging.basicConfig( level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', handlers=[ logging.FileHandler("bot_log.log"), logging.StreamHandler() ] ) logger = logging.getLogger(__name__) # Bot Configuration BOT_TOKEN = os.getenv("BOT_TOKEN") TARGET_USER_ID = int(os.getenv("TARGET_USER_ID", "5942712950")) API_URL = os.getenv("API_URL", "https://draw.ar-lottery01.com/K3/K3_1M/GetHistoryIssuePage.json") # Initialize the bot bot = telebot.TeleBot(BOT_TOKEN) # Global variables to track predictions and results predictions = [] daily_stats = { "total_predictions": 0, "correct_predictions": 0, "last_morning_greeting": None # Track when we last sent a morning greeting } class GameResult: def __init__(self, period: str, numbers: List[int], sum_value: int, timestamp: int): self.period = period self.numbers = numbers self.sum_value = sum_value self.timestamp = timestamp self.datetime = datetime.datetime.fromtimestamp(timestamp) def __str__(self) -> str: return f"Period {self.period}: {self.numbers} = {self.sum_value}" class Prediction: def __init__(self, start_period: str, end_period: str, strategy_results: Dict[str, bool]): self.start_period = start_period self.end_period = end_period self.strategy_results = strategy_results self.confidence = sum(1 for result in strategy_results.values() if result) / len(strategy_results) self.prediction_time = datetime.datetime.now() self.result = None # Will be set to True/False after validation def is_confident(self) -> bool: # At least 7 out of 10 strategies must confirm return self.confidence >= 0.7 def format_message(self) -> str: message = "High Probability Detected\n\n" message += f"Next 10-min window: Period {self.start_period} to {self.end_period}\n" message += "Target: 3 or 18\n\n" message += "âœ… Strategy Confirmations:\n" for idx, (strategy_name, passed) in enumerate(self.strategy_results.items(), 1): status = "Passed" if passed else "Failed" message += f"- Strategy {idx}: {status}\n" passed_count = sum(1 for result in self.strategy_results.values() if result) message += f"\nConfidence: {passed_count}/10 Strategies Confirmed" return message def format_validation_message(self, result_period: Optional[str] = None) -> str: if self.result: return f"âœ… Prediction Correct\n3 or 18 appeared in period {result_period}" else: return f"â�Œ Prediction Incorrect\n3 or 18 did not appear from {self.start_period} to {self.end_period}" class StrategyEngine: def __init__(self): pass def analyze(self, results: List[GameResult]) -> Dict[str, bool]: """Run all strategies and return results""" if not results or len(results) < 40: # Need sufficient history for analysis return {f"Strategy {i+1}": False for i in range(10)} strategy_results = { "Strategy 1": self.reversal_bounce_detection(results), "Strategy 2": self.odd_even_saturation_breach(results), "Strategy 3": self.low_high_low_w_pattern(results), "Strategy 4": self.ai_spike_prediction_model(results), "Strategy 5": self.mirror_pattern_reflection(results), "Strategy 6": self.fibonacci_interval_trigger(results), "Strategy 7": self.compressed_rng_zone_detection(results), "Strategy 8": self.anomaly_gap_breaker(results), "Strategy 9": self.alternating_sum_trap(results), "Strategy 10": self.period_time_sync_trigger(results) } return strategy_results def reversal_bounce_detection(self, results: List[GameResult]) -> bool: """Strategy 1: Reversal Bounce Detection If long absence of 3/18 is seen (>20 periods), and RNG stabilizes suddenly (e.g., 2â€“3 repeating sums), it indicates pattern exhaustion â†’ Reversal bounce may result in extreme number. """ # Check for absence of 3/18 last_extreme = next((i for i, r in enumerate(results) if r.sum_value in [3, 18]), None) if last_extreme is None or last_extreme > 20: # No 3/18 in last 20+ periods # Check for stabilization (repeating sums) repeats = 0 for i in range(1, min(10, len(results))): if results[i].sum_value == results[i-1].sum_value: repeats += 1 return repeats >= 2 # At least 2 repeating sums return False def odd_even_saturation_breach(self, results: List[GameResult]) -> bool: """Strategy 2: Odd-Even Saturation Breach If Odd or Even appears more than 4 times in a row, with no appearance of 3 or 18, it increases chances of extreme RNG jump toward low/high edge (like 3 or 18). """ # Check last 10 results recent_results = results[:10] # Check if 3 or 18 appeared recently if any(r.sum_value in [3, 18] for r in recent_results): return False # Count consecutive odd/even odd_streak = 0 even_streak = 0 max_odd_streak = 0 max_even_streak = 0 for r in recent_results: if r.sum_value % 2 == 0: # Even even_streak += 1 odd_streak = 0 max_even_streak = max(max_even_streak, even_streak) else: # Odd odd_streak += 1 even_streak = 0 max_odd_streak = max(max_odd_streak, odd_streak) return max_odd_streak >= 4 or max_even_streak >= 4 def low_high_low_w_pattern(self, results: List[GameResult]) -> bool: """Strategy 3: Lowâ€“Highâ€“Low W Pattern If pattern goes from low (4â€“6) â†’ high (14â€“17) â†’ low again in 10 periods, it often prepares RNG to balance at extremes like 3 or 18. """ if len(results) < 10: return False recent_results = results[:10] # Define low and high ranges low_range = range(4, 7) # 4-6 high_range = range(14, 18) # 14-17 # Look for low â†’ high â†’ low pattern pattern_found = False for i in range(len(recent_results) - 2): if (recent_results[i].sum_value in low_range and recent_results[i+1].sum_value in high_range and recent_results[i+2].sum_value in low_range): pattern_found = True break return pattern_found def ai_spike_prediction_model(self, results: List[GameResult]) -> bool: """Strategy 4: AI Spike Prediction Model Using short-term volatility + frequency of edge numbers, AI agent evaluates if an RNG spike is expected, pushing toward 3 or 18. """ if len(results) < 20: return False recent_results = results[:20] # Calculate volatility (standard deviation of sums) sums = [r.sum_value for r in recent_results] mean = sum(sums) / len(sums) variance = sum((x - mean) ** 2 for x in sums) / len(sums) volatility = variance ** 0.5 # Count edge numbers (close to 3 or 18) edge_count = sum(1 for r in recent_results if r.sum_value in [4, 5, 16, 17]) # High volatility + presence of edge numbers suggests potential spike return volatility > 3.5 and edge_count >= 3 def mirror_pattern_reflection(self, results: List[GameResult]) -> bool: """Strategy 5: Mirror Pattern Reflection Check if any past set of 5 periods had mirrored outcomes (sum 10 â†” sum 11, 14 â†” 13), then often a hard-edge number appears (3/18). """ if len(results) < 15: return False recent_results = results[:15] # Define mirror pairs mirror_pairs = [(10, 11), (9, 12), (8, 13), (7, 14), (6, 15), (5, 16), (4, 17)] # Check for mirror patterns in consecutive results mirror_count = 0 for i in range(len(recent_results) - 1): current = recent_results[i].sum_value next_val = recent_results[i+1].sum_value if any(current in pair and next_val in pair for pair in mirror_pairs): mirror_count += 1 return mirror_count >= 2 # At least 2 mirror patterns found def fibonacci_interval_trigger(self, results: List[GameResult]) -> bool: """Strategy 6: Fibonacci Interval Trigger If sum numbers follow Fibonacci gaps (e.g., 8, 13, 21 gap periods without 3 or 18), system triggers probability of breakout at Fibonacci thresholds. """ # Find last occurrence of 3 or 18 last_extreme_idx = next((i for i, r in enumerate(results) if r.sum_value in [3, 18]), None) if last_extreme_idx is None: return False # No 3/18 found in history # Calculate gap gap = last_extreme_idx # Fibonacci thresholds fib_thresholds = [8, 13, 21, 34] # Check if gap is close to a Fibonacci threshold for threshold in fib_thresholds: if abs(gap - threshold) <= 1: # Within 1 period of threshold return True return False def compressed_rng_zone_detection(self, results: List[GameResult]) -> bool: """Strategy 7: Compressed RNG Zone Detection If RNG stays compressed between 7 and 14 for too long (10+ periods), it often expands by releasing extremes. """ if len(results) < 10: return False recent_results = results[:10] # Check if all recent results are in the compressed zone compressed_count = sum(1 for r in recent_results if 7 <= r.sum_value <= 14) return compressed_count >= 8 # At least 8 out of 10 are compressed def anomaly_gap_breaker(self, results: List[GameResult]) -> bool: """Strategy 8: Anomaly Gap Breaker If 3 or 18 hasn't occurred for 40+ periods but middle-range numbers have repeated heavily, system predicts inevitable RNG correction. """ # Find last occurrence of 3 or 18 last_extreme_idx = next((i for i, r in enumerate(results) if r.sum_value in [3, 18]), None) if last_extreme_idx is None or last_extreme_idx >= 40: # No 3/18 in 40+ periods # Check for middle-range repetition middle_range = range(8, 14) # 8-13 middle_count = sum(1 for r in results[:20] if r.sum_value in middle_range) return middle_count >= 15 # At least 15 out of 20 are middle range return False def alternating_sum_trap(self, results: List[GameResult]) -> bool: """Strategy 9: Alternating Sum Trap When sums alternate (10â€“14â€“10â€“15), it indicates unstable pattern, ideal for breaking into either 3 or 18 within 5â€“10 periods. """ if len(results) < 6: return False recent_results = results[:6] # Check for alternating pattern alternating_count = 0 for i in range(len(recent_results) - 2): # Check if current differs from next and next differs from next+1 if (abs(recent_results[i].sum_value - recent_results[i+1].sum_value) >= 3 and abs(recent_results[i+1].sum_value - recent_results[i+2].sum_value) >= 3): alternating_count += 1 return alternating_count >= 2 # At least 2 alternating patterns def period_time_sync_trigger(self, results: List[GameResult]) -> bool: """Strategy 10: Period-Time Sync Trigger If period number ends in 3, 8, or 0, and matches time xx:03, xx:08, or xx:10, AI marks this RNG trigger point as a rare edge appearance cue. """ if not results: return False latest_result = results[0] # Check if period ends with 3, 8, or 0 period_last_digit = int(latest_result.period[-1]) if period_last_digit not in [3, 8, 0]: return False # Check if time matches xx:03, xx:08, or xx:10 minute = latest_result.datetime.minute second = latest_result.datetime.second time_match = False if period_last_digit == 3 and minute % 10 == 3 and 0 <= second <= 30: time_match = True elif period_last_digit == 8 and minute % 10 == 8 and 0 <= second <= 30: time_match = True elif period_last_digit == 0 and minute % 10 == 0 and 0 <= second <= 30: time_match = True return time_match class GameMonitor: def __init__(self): self.strategy_engine = StrategyEngine() self.last_checked_period = None self.current_prediction = None self.validation_queue = [] # Store predictions waiting for validation def fetch_results(self) -> List[GameResult]: """Fetch game results from the API with improved retry logic""" max_retries = 3 retry_count = 0 retry_delay = 2 # seconds while retry_count < max_retries: try: timestamp = int(time.time() * 1000) # Current timestamp in milliseconds url = f"{API_URL}?ts={timestamp}" logger.info(f"Fetching results from {url} (attempt {retry_count+1}/{max_retries})") response = requests.get(url, timeout=10) response.raise_for_status() data = response.json() results = [] if not data or 'data' not in data or 'list' not in data.get('data', {}): logger.warning(f"Invalid API response format: {data}") retry_count += 1 time.sleep(retry_delay) # Wait before retrying retry_delay *= 1.5 # Exponential backoff continue for item in data.get('data', {}).get('list', []): try: period = item.get('issue') numbers_str = item.get('code', '') if not period or not numbers_str: logger.warning(f"Missing data in item: {item}") continue numbers = [int(n) for n in numbers_str.split(',')] sum_value = sum(numbers) timestamp = int(item.get('openTime', 0)) / 1000 # Convert to seconds results.append(GameResult(period, numbers, sum_value, timestamp)) except (ValueError, TypeError, AttributeError) as e: logger.error(f"Error parsing result: {e}, item: {item}") continue if not results: logger.warning("No valid results found in API response") retry_count += 1 time.sleep(retry_delay) # Wait before retrying retry_delay *= 1.5 # Exponential backoff continue # Sort by period (newest first) results.sort(key=lambda x: x.period, reverse=True) logger.info(f"Successfully fetched {len(results)} results") return results except requests.exceptions.RequestException as e: logger.error(f"Request error: {e}") retry_count += 1 logger.info(f"Retrying in {retry_delay} seconds...") time.sleep(retry_delay) # Wait before retrying retry_delay *= 1.5 # Exponential backoff except json.JSONDecodeError as e: logger.error(f"JSON decode error: {e}") retry_count += 1 logger.info(f"Retrying in {retry_delay} seconds...") time.sleep(retry_delay) # Wait before retrying retry_delay *= 1.5 # Exponential backoff except Exception as e: logger.error(f"Unexpected error fetching results: {e}") retry_count += 1 logger.info(f"Retrying in {retry_delay} seconds...") time.sleep(retry_delay) # Wait before retrying retry_delay *= 1.5 # Exponential backoff logger.error(f"Failed to fetch results after {max_retries} attempts") return [] def make_prediction(self, results: List[GameResult]) -> Optional[Prediction]: """Analyze results and make a prediction if confident""" if not results: return None # Get current period current_period = results[0].period # Skip if we've already checked this period if self.last_checked_period == current_period: return None self.last_checked_period = current_period # Calculate start and end periods for the 10-minute window (10 periods) current_period_num = int(current_period) start_period = str(current_period_num) end_period = str(current_period_num + 9) # Run all strategies strategy_results = self.strategy_engine.analyze(results) # Create prediction prediction = Prediction(start_period, end_period, strategy_results) # Only return if confident if prediction.is_confident(): return prediction return None def validate_prediction(self, prediction: Prediction, results: List[GameResult]) -> bool: """Validate if a prediction was correct""" start_period_num = int(prediction.start_period) end_period_num = int(prediction.end_period) # Find results in the prediction window window_results = [r for r in results if start_period_num <= int(r.period) <= end_period_num] # Check if 3 or 18 appeared for result in window_results: if result.sum_value in [3, 18]: prediction.result = True return True, result.period # If we have all results for the window and no 3/18, prediction was wrong if len(window_results) == (end_period_num - start_period_num + 1): prediction.result = False return False, None # Not enough results to validate yet return None, None def check_validation_queue(self, results: List[GameResult]): """Check and validate pending predictions""" for prediction in self.validation_queue[:]: # Use a copy for iteration result, period = self.validate_prediction(prediction, results) if result is not None: # Validation complete self.validation_queue.remove(prediction) # Update daily stats daily_stats["total_predictions"] += 1 if result: daily_stats["correct_predictions"] += 1 # Send validation message validation_message = prediction.format_validation_message(period) send_message(validation_message) def run(self): """Main monitoring loop""" consecutive_errors = 0 max_consecutive_errors = 5 while True: try: # Fetch latest results results = self.fetch_results() if not results: logger.warning("No results fetched, retrying in 5 seconds") time.sleep(5) consecutive_errors += 1 if consecutive_errors >= max_consecutive_errors: logger.error(f"Too many consecutive errors ({consecutive_errors}). Not sending error notification as per user preference.") # No error message sent, only log the error consecutive_errors = 0 # Reset after reaching threshold continue # Reset error counter on success consecutive_errors = 0 # Check validation queue first try: self.check_validation_queue(results) except Exception as e: logger.error(f"Error in validation queue: {e}") # Continue execution even if validation fails # Make new prediction if needed try: prediction = self.make_prediction(results) if prediction: # Send prediction message prediction_message = prediction.format_message() send_message(prediction_message) # Add to validation queue self.validation_queue.append(prediction) # Store prediction for stats predictions.append(prediction) except Exception as e: logger.error(f"Error making prediction: {e}") # Check if it's time for daily summary (12:00 AM) now = datetime.datetime.now() if now.hour == 0 and now.minute == 0 and 0 <= now.second < 10: try: send_daily_summary() # Also send morning greeting at 12:00 AM send_morning_greeting() except Exception as e: logger.error(f"Error sending daily summary or greeting: {e}") # Sleep for a few seconds before next check time.sleep(5) except Exception as e: logger.error(f"Error in monitoring loop: {e}") consecutive_errors += 1 if consecutive_errors >= max_consecutive_errors: logger.error(f"Too many consecutive errors ({consecutive_errors}). Not sending error notification as per user preference.") # No error message sent, only log the error consecutive_errors = 0 # Reset after reaching threshold time.sleep(10) # Longer sleep on error def send_message(message: str): """Send message to the target user""" try: bot.send_message(TARGET_USER_ID, message) logger.info(f"Message sent: {message[:50]}...") except Exception as e: logger.error(f"Error sending message: {e}") def send_daily_summary(): """Send daily summary of predictions""" total = daily_stats["total_predictions"] correct = daily_stats["correct_predictions"] accuracy = (correct / total * 100) if total > 0 else 0 message = "ðŸ“Š Daily Summary:\n" message += f"Total Predictions: {total}\n" message += f"Correct Predictions: {correct}\n" message += f"Accuracy: {accuracy:.1f}%" send_message(message) # Reset daily stats daily_stats["total_predictions"] = 0 daily_stats["correct_predictions"] = 0 def send_morning_greeting(): """Send good morning message with prediction day information""" today = datetime.datetime.now().date() # Check if we already sent a greeting today if daily_stats["last_morning_greeting"] == today: return # Get the day of the week day_name = today.strftime("%A") # Create the greeting message message = f"ðŸŒž Good Morning!\n\nWelcome to a new prediction day: {day_name}\n\n" message += "I'm actively monitoring the BDG K3 Game for high-confidence patterns.\n" message += "Stay tuned for predictions throughout the day!" # Send the message send_message(message) # Update the last greeting date daily_stats["last_morning_greeting"] = today def main(): logger.info("Starting BDG K3 Game Monitor Bot") # Send startup message startup_message = "ðŸ¤– Trae AI Agent Activated\n\n" startup_message += "Monitoring BDG K3 Game for high-confidence predictions of 3 or 18\n" startup_message += "Using 10 world-advanced strategies for analysis\n" startup_message += "Daily summaries will be provided at 12:00 AM" send_message(startup_message) # Start monitoring monitor = GameMonitor() monitor.run() if __name__ == "__main__": main()
